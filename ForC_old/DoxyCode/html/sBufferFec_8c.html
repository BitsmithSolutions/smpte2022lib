<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VLC-SMPTE:  VLC-SMPTE/DoxyCode/Code/sBufferFec.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1> VLC-SMPTE/DoxyCode/Code/sBufferFec.c File Reference</h1><code>#include &quot;../smpte.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#e06dfb17ff21b68c2b459aa741e6886f">ReleaseCrossFunc</a> (uint32_t pKey, void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Libère un noeud du type cross.  <a href="#e06dfb17ff21b68c2b459aa741e6886f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#f84a56f4ae068bea0ca16aa8c5901cd7">ReleaseWaitFunc</a> (uint32_t pKey, void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Libère un noeud du type wait.  <a href="#f84a56f4ae068bea0ca16aa8c5901cd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#897b200dd8391d095a06aec8c7f4b738">PrintCrossFunc</a> (void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche un noeud du type cross.  <a href="#897b200dd8391d095a06aec8c7f4b738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#8eff440a13e77d9e3c95f4882e1a77a2">PrintWaitFunc</a> (void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche un noeud du type wait.  <a href="#8eff440a13e77d9e3c95f4882e1a77a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsBufferFec.html">sBufferFec</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#93eccabeeba94759f2d9a5b1ae65cd1f">sBufferFec_New</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Créé un buffer de FEC Remarque : ne pas oublier de faire le ménage avec sBufferFec_Release !  <a href="#93eccabeeba94759f2d9a5b1ae65cd1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#23d8d06b623e97b958a29fbebd324f84">sBufferFec_Release</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Libère la mémoire allouée par un buffer de FEC.  <a href="#23d8d06b623e97b958a29fbebd324f84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#31d2a565f8b3d11af6bcdb150d1eb125">sBufferFec_AddCrossByReference</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> pMediaNo, <a class="el" href="structsCrossFec.html">sCrossFec</a> *pCross, bool pOver)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insère un nouveau cross dans le buffer de FEC.  <a href="#31d2a565f8b3d11af6bcdb150d1eb125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsCrossFec.html">sCrossFec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#b2d30a7f2605e456a8c1217cd6405a0b">sBufferFec_FindCross</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> pMediaNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrouve un cross lié au médiaNo donné en paramètre.  <a href="#b2d30a7f2605e456a8c1217cd6405a0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#34c88802fa74f6ce1c944bbf27f891a7">sBufferFec_DeleteCross</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> pMediaNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supprime un cross.  <a href="#34c88802fa74f6ce1c944bbf27f891a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#8b9dcf01a055beea658723baba751f62">sBufferFec_AddWaitByReference</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="structsWaitFec.html">sWaitFec</a> *pWait, bool pOver)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insère un nouveau wait.  <a href="#8b9dcf01a055beea658723baba751f62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsWaitFec.html">sWaitFec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#bf739be65b16f804a03c04cacde4d4fe">sBufferFec_FindWait</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a> pD, <a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a> pFecNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrouve un wait lié à une direction et un fecNo donné en paramètre.  <a href="#bf739be65b16f804a03c04cacde4d4fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#ff8e6823c10c9e7f856147d50ab62a55">sBufferFec_DeleteWait</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a> pD, <a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a> pFecNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supprimer un wait du buffer de FEC.  <a href="#ff8e6823c10c9e7f856147d50ab62a55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#5cdbe5739f227049f7467df3642b545c">sBufferFec_DeleteCrossAndWait</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a> pD, <a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a> pFecNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fait le ménage en supprimant toutes traces concernant un paquet de FEC particulier. Ce nettoyage est nécessaire au cas où certains paquets de FEC seraient devenus obsolètes. Par exemple il serait inutile de récupérer des paquets média déjà " sautés " (manquants à la lecture) par le player...  <a href="#5cdbe5739f227049f7467df3642b545c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#e322c3fdc80ac5b92fd5d9985880a9f5">sBufferFec_PrintCross</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, bool pBuffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche le contenu du buffer cross.  <a href="#e322c3fdc80ac5b92fd5d9985880a9f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#0add9723fc1ac7961d2b6b3dfaedd608">sBufferFec_PrintWait</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, <a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a> pD, bool pBuffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche le contenu du buffer wait.  <a href="#0add9723fc1ac7961d2b6b3dfaedd608"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#2e863c656e59b333ee6170b4b38c88ae">sBufferFec_InitForeachCross</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer, bool pReverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initalise la boucle foreach like sur le buffer de FEC (cross).  <a href="#2e863c656e59b333ee6170b4b38c88ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#470649c7c9c89469b77ee862aac0941b">sBufferFec_NextForeachCross</a> (<a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue la boucle foreach like sur le buffer de FEC (cross).  <a href="#470649c7c9c89469b77ee862aac0941b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#9d777eb348680ea03a917183f49a8e92">sBufferFec_ForeachKeyCross</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne le médiaNo lié au cross (pointé) par la boucle foreach.  <a href="#9d777eb348680ea03a917183f49a8e92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsCrossFec.html">sCrossFec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferFec_8c.html#8298cc8abee0d5df21e93031d7d82282">sBufferFec_ForeachValueCross</a> (const <a class="el" href="structsBufferFec.html">sBufferFec</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne un pointeur sur le cross (pointé) par la boucle foreach.  <a href="#8298cc8abee0d5df21e93031d7d82282"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="897b200dd8391d095a06aec8c7f4b738"></a><!-- doxytag: member="sBufferFec.c::PrintCrossFunc" ref="897b200dd8391d095a06aec8c7f4b738" args="(void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintCrossFunc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche un noeud du type cross. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur (cross) du noeud</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8eff440a13e77d9e3c95f4882e1a77a2"></a><!-- doxytag: member="sBufferFec.c::PrintWaitFunc" ref="8eff440a13e77d9e3c95f4882e1a77a2" args="(void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintWaitFunc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche un noeud du type wait. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur (wait) du noeud</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e06dfb17ff21b68c2b459aa741e6886f"></a><!-- doxytag: member="sBufferFec.c::ReleaseCrossFunc" ref="e06dfb17ff21b68c2b459aa741e6886f" args="(uint32_t pKey, void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReleaseCrossFunc           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Libère un noeud du type cross. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pKey</em>&nbsp;</td><td>Clé (médiaNo) du noeud à supprimer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur (cross) du noeud à supprimer</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f84a56f4ae068bea0ca16aa8c5901cd7"></a><!-- doxytag: member="sBufferFec.c::ReleaseWaitFunc" ref="f84a56f4ae068bea0ca16aa8c5901cd7" args="(uint32_t pKey, void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReleaseWaitFunc           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Libère un noeud du type wait. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pKey</em>&nbsp;</td><td>Clé (fecNo) du noeud à supprimer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur (wait) du noeud à supprimer</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="31d2a565f8b3d11af6bcdb150d1eb125"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_AddCrossByReference" ref="31d2a565f8b3d11af6bcdb150d1eb125" args="(sBufferFec *pBuffer, sMediaNo pMediaNo, sCrossFec *pCross, bool pOver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_AddCrossByReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsCrossFec.html">sCrossFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pCross</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pOver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insère un nouveau cross dans le buffer de FEC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMediaNo</em>&nbsp;</td><td>Lier le cross à ce médiaNo</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pCross</em>&nbsp;</td><td>Cross à ajouter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pOver</em>&nbsp;</td><td>Faut-il écraser un noeud qui porterait déjà key=médiaNo ?</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / ajout réussi ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="8b9dcf01a055beea658723baba751f62"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_AddWaitByReference" ref="8b9dcf01a055beea658723baba751f62" args="(sBufferFec *pBuffer, sWaitFec *pWait, bool pOver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_AddWaitByReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsWaitFec.html">sWaitFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pWait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pOver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insère un nouveau wait. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pWait</em>&nbsp;</td><td>Wait à ajouter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pOver</em>&nbsp;</td><td>Faut-il écraser un noeud qui porterait déjà key=pWait.fecNo ?</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération</dd></dl>

</div>
</div><p>
<a class="anchor" name="34c88802fa74f6ce1c944bbf27f891a7"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_DeleteCross" ref="34c88802fa74f6ce1c944bbf27f891a7" args="(sBufferFec *pBuffer, sMediaNo pMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_DeleteCross           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Supprime un cross. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMediaNo</em>&nbsp;</td><td>MédiaNo du cross à supprimer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération</dd></dl>

</div>
</div><p>
<a class="anchor" name="5cdbe5739f227049f7467df3642b545c"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_DeleteCrossAndWait" ref="5cdbe5739f227049f7467df3642b545c" args="(sBufferFec *pBuffer, eFecD pD, sFecNo pFecNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_DeleteCrossAndWait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a>&nbsp;</td>
          <td class="paramname"> <em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a>&nbsp;</td>
          <td class="paramname"> <em>pFecNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fait le ménage en supprimant toutes traces concernant un paquet de FEC particulier. Ce nettoyage est nécessaire au cas où certains paquets de FEC seraient devenus obsolètes. Par exemple il serait inutile de récupérer des paquets média déjà " sautés " (manquants à la lecture) par le player... 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Faut-il opérer dans wait[COL] ou wait[ROW] ?</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFecNo</em>&nbsp;</td><td>fecNo du wait (cross retrouvés depuis le wait)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / nettoyage réussi ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="ff8e6823c10c9e7f856147d50ab62a55"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_DeleteWait" ref="ff8e6823c10c9e7f856147d50ab62a55" args="(sBufferFec *pBuffer, eFecD pD, sFecNo pFecNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_DeleteWait           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a>&nbsp;</td>
          <td class="paramname"> <em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a>&nbsp;</td>
          <td class="paramname"> <em>pFecNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Supprimer un wait du buffer de FEC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Faut-il opérer dans wait[COL] ou wait[ROW] ?</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFecNo</em>&nbsp;</td><td>fecNo du wait à supprimer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / suppression réussie ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="b2d30a7f2605e456a8c1217cd6405a0b"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_FindCross" ref="b2d30a7f2605e456a8c1217cd6405a0b" args="(const sBufferFec *pBuffer, sMediaNo pMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsCrossFec.html">sCrossFec</a>* sBufferFec_FindCross           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrouve un cross lié au médiaNo donné en paramètre. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à traiter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMediaNo</em>&nbsp;</td><td>Paramètre de recherche</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur le cross lié à key=médiaNo ou 0 si inexistant</dd></dl>

</div>
</div><p>
<a class="anchor" name="bf739be65b16f804a03c04cacde4d4fe"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_FindWait" ref="bf739be65b16f804a03c04cacde4d4fe" args="(const sBufferFec *pBuffer, eFecD pD, sFecNo pFecNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsWaitFec.html">sWaitFec</a>* sBufferFec_FindWait           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a>&nbsp;</td>
          <td class="paramname"> <em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#578352fc0de2d7f6825fdfa6269ec909">sFecNo</a>&nbsp;</td>
          <td class="paramname"> <em>pFecNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrouve un wait lié à une direction et un fecNo donné en paramètre. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à traiter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Faut-il chercher dans wait[COL] ou wait[ROW] ?</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFecNo</em>&nbsp;</td><td>Paramètre de recherche</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur le wait[direction=D] lié à key=fecNo ou 0 si inexistant</dd></dl>

</div>
</div><p>
<a class="anchor" name="9d777eb348680ea03a917183f49a8e92"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_ForeachKeyCross" ref="9d777eb348680ea03a917183f49a8e92" args="(const sBufferFec *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> sBufferFec_ForeachKeyCross           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne le médiaNo lié au cross (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>médiaNo lié au cross (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="8298cc8abee0d5df21e93031d7d82282"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_ForeachValueCross" ref="8298cc8abee0d5df21e93031d7d82282" args="(const sBufferFec *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsCrossFec.html">sCrossFec</a>* sBufferFec_ForeachValueCross           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne un pointeur sur le cross (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur le cross (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="2e863c656e59b333ee6170b4b38c88ae"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_InitForeachCross" ref="2e863c656e59b333ee6170b4b38c88ae" args="(sBufferFec *pBuffer, bool pReverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_InitForeachCross           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pReverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initalise la boucle foreach like sur le buffer de FEC (cross). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un cross) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="93eccabeeba94759f2d9a5b1ae65cd1f"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_New" ref="93eccabeeba94759f2d9a5b1ae65cd1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsBufferFec.html">sBufferFec</a> sBufferFec_New           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Créé un buffer de FEC Remarque : ne pas oublier de faire le ménage avec sBufferFec_Release ! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Nouveau buffer de FEC</dd></dl>

</div>
</div><p>
<a class="anchor" name="470649c7c9c89469b77ee862aac0941b"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_NextForeachCross" ref="470649c7c9c89469b77ee862aac0941b" args="(sBufferFec *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferFec_NextForeachCross           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continue la boucle foreach like sur le buffer de FEC (cross). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un cross) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="e322c3fdc80ac5b92fd5d9985880a9f5"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_PrintCross" ref="e322c3fdc80ac5b92fd5d9985880a9f5" args="(const sBufferFec *pBuffer, bool pBuffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferFec_PrintCross           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche le contenu du buffer cross. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffers</em>&nbsp;</td><td>Faut-il afficher le contenu des buffers ?</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0add9723fc1ac7961d2b6b3dfaedd608"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_PrintWait" ref="0add9723fc1ac7961d2b6b3dfaedd608" args="(const sBufferFec *pBuffer, eFecD pD, bool pBuffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferFec_PrintWait           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sPaquetFec_8h.html#866cd357ed6b914809b44f7938c24467">eFecD</a>&nbsp;</td>
          <td class="paramname"> <em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche le contenu du buffer wait. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Faut-il afficher wait[COL] ou wait[ROW] ?</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffers</em>&nbsp;</td><td>Faut-il afficher le contenu des buffers ?</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="23d8d06b623e97b958a29fbebd324f84"></a><!-- doxytag: member="sBufferFec.c::sBufferFec_Release" ref="23d8d06b623e97b958a29fbebd324f84" args="(sBufferFec *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferFec_Release           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferFec.html">sBufferFec</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Libère la mémoire allouée par un buffer de FEC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à vider</td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 7 18:21:25 2009 for VLC-SMPTE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
