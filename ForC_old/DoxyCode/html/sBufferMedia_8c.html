<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VLC-SMPTE:  VLC-SMPTE/DoxyCode/Code/sBufferMedia.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1> VLC-SMPTE/DoxyCode/Code/sBufferMedia.c File Reference</h1><code>#include &quot;../smpte.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#5c212d00bbbc85514072821ed51c4c1e">ReleasePaquetMediaFunc</a> (uint32_t pKey, void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fonction appelée par l'arbre rb lors de la suppression d'un noeud.  <a href="#5c212d00bbbc85514072821ed51c4c1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#b51bdb0f6170e663fe2f44632a3a8b51">PrintPaquetMediaFunc</a> (void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fonction appelée par l'arbre rb lors de l'affichage d'un noeud.  <a href="#b51bdb0f6170e663fe2f44632a3a8b51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsBufferMedia.html">sBufferMedia</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#6fb6d04f09d456526ff473d3fd145d61">sBufferMedia_New</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Créé un buffer média Remarque : ne pas oublier de faire le ménage avec sBufferMedia_Release !  <a href="#6fb6d04f09d456526ff473d3fd145d61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#37d79a8fb4cb51476a3580c8580b546a">sBufferMedia_Release</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Libère la mémoire allouée par un buffer média.  <a href="#37d79a8fb4cb51476a3580c8580b546a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#ca27f598c501dc91f1b4556bedb6c1e0">sBufferMedia_Print</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, bool pBuffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche le contenu d'un buffer média.  <a href="#ca27f598c501dc91f1b4556bedb6c1e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#88c28ea074592b35063061e5d07c187b">sBufferMedia_AddByReference</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, <a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *pMedia, bool pOver)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Est "l'équivalent" de media_receive de VLC : ajoute le paquet média au buffer, celui-ci étant trié par ordre de médiaNo. Remarque: Le buffer s'approprie le paquet média, cela veut dire que c'est le buffer média qui s'occupera de libérer la mémoire prise par le paquet!  <a href="#88c28ea074592b35063061e5d07c187b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#84c30ca0d6135bc899474b2e672a192b">sBufferMedia_Find</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> pMediaNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne un pointeur vers le paquet média portant un certain médiaNo.  <a href="#84c30ca0d6135bc899474b2e672a192b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#73b0d0615fc8c54eba1ee02190d8a388">sBufferMedia_InitForeach</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, bool pReverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initalise la boucle foreach like sur le buffer média.  <a href="#73b0d0615fc8c54eba1ee02190d8a388"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#1d322647e37296f007d4d769f74f8db2">sBufferMedia_NextForeach</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue la boucle foreach like sur le buffer média.  <a href="#1d322647e37296f007d4d769f74f8db2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#bb329a1690944abbc846f1538608b705">sBufferMedia_ForeachKey</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne le médiaNo du paquet média (pointé) par la boucle foreach.  <a href="#bb329a1690944abbc846f1538608b705"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#ddb31fcee92bcae764beb4ec38e0273e">sBufferMedia_ForeachValue</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne un pointeur sur le paquet média (pointé) par la boucle foreach.  <a href="#ddb31fcee92bcae764beb4ec38e0273e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#f4114d4c90298b73ba086f79cb7b0462">sBufferMedia_IsMediaNoInBuffer</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> pMediaNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calcule si un médiaNo se situe entre les limites d'arrivalNx &amp; readingNx La valeur de médiaNo est modulaire donc 2 cas de figures se présentent : cas [1] 0 false [readingNo] true [arrivalNo] false MAX cas [2] 0 true [arrivalNo] false [readingNo] true MAX.  <a href="#f4114d4c90298b73ba086f79cb7b0462"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8c.html#2b71a2b21e86d18a53722a9070c69e48">sBufferMedia_ReadMedia</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *pBuffer, FILE *pDestFile, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> *pReadedNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simule la " lecture " d'un paquet du buffer (enregistre son payload dans un fichier, si pDestFile!=0, et supprime le paquet pointé par lectureNx).  <a href="#2b71a2b21e86d18a53722a9070c69e48"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b51bdb0f6170e663fe2f44632a3a8b51"></a><!-- doxytag: member="sBufferMedia.c::PrintPaquetMediaFunc" ref="b51bdb0f6170e663fe2f44632a3a8b51" args="(void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintPaquetMediaFunc           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fonction appelée par l'arbre rb lors de l'affichage d'un noeud. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur du noeud à afficher</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5c212d00bbbc85514072821ed51c4c1e"></a><!-- doxytag: member="sBufferMedia.c::ReleasePaquetMediaFunc" ref="5c212d00bbbc85514072821ed51c4c1e" args="(uint32_t pKey, void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReleasePaquetMediaFunc           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fonction appelée par l'arbre rb lors de la suppression d'un noeud. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pKey</em>&nbsp;</td><td>Clé (médiaNo) du noeud à supprimer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>Valeur du noeud à supprimer</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="88c28ea074592b35063061e5d07c187b"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_AddByReference" ref="88c28ea074592b35063061e5d07c187b" args="(sBufferMedia *pBuffer, sPaquetMedia *pMedia, bool pOver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_AddByReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pMedia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pOver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Est "l'équivalent" de media_receive de VLC : ajoute le paquet média au buffer, celui-ci étant trié par ordre de médiaNo. Remarque: Le buffer s'approprie le paquet média, cela veut dire que c'est le buffer média qui s'occupera de libérer la mémoire prise par le paquet! 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMedia</em>&nbsp;</td><td>Paquet à ajouter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pOver</em>&nbsp;</td><td>Faut-il écraser un noeud qui porterait déjà key=médiaNo ?</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / ajout réussi ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="84c30ca0d6135bc899474b2e672a192b"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_Find" ref="84c30ca0d6135bc899474b2e672a192b" args="(const sBufferMedia *pBuffer, sMediaNo pMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a>* sBufferMedia_Find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne un pointeur vers le paquet média portant un certain médiaNo. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à traiter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMediaNo</em>&nbsp;</td><td>Paramètre de recherche</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur le paquet média lié à key=pMediaNo ou 0 si aucun de trouvé</dd></dl>

</div>
</div><p>
<a class="anchor" name="bb329a1690944abbc846f1538608b705"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_ForeachKey" ref="bb329a1690944abbc846f1538608b705" args="(const sBufferMedia *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> sBufferMedia_ForeachKey           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne le médiaNo du paquet média (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>médiaNo du paquet média (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="ddb31fcee92bcae764beb4ec38e0273e"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_ForeachValue" ref="ddb31fcee92bcae764beb4ec38e0273e" args="(const sBufferMedia *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a>* sBufferMedia_ForeachValue           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne un pointeur sur le paquet média (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur la paquet média (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="73b0d0615fc8c54eba1ee02190d8a388"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_InitForeach" ref="73b0d0615fc8c54eba1ee02190d8a388" args="(sBufferMedia *pBuffer, bool pReverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_InitForeach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pReverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initalise la boucle foreach like sur le buffer média. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un paquet) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="f4114d4c90298b73ba086f79cb7b0462"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_IsMediaNoInBuffer" ref="f4114d4c90298b73ba086f79cb7b0462" args="(const sBufferMedia *pBuffer, sMediaNo pMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_IsMediaNoInBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calcule si un médiaNo se situe entre les limites d'arrivalNx &amp; readingNx La valeur de médiaNo est modulaire donc 2 cas de figures se présentent : cas [1] 0 false [readingNo] true [arrivalNo] false MAX cas [2] 0 true [arrivalNo] false [readingNo] true MAX. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Est-ce que médiaNo se situe dans la zone entre lecture et arrivée (buffer) ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="6fb6d04f09d456526ff473d3fd145d61"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_New" ref="6fb6d04f09d456526ff473d3fd145d61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> sBufferMedia_New           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Créé un buffer média Remarque : ne pas oublier de faire le ménage avec sBufferMedia_Release ! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Nouveau buffer média</dd></dl>

</div>
</div><p>
<a class="anchor" name="1d322647e37296f007d4d769f74f8db2"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_NextForeach" ref="1d322647e37296f007d4d769f74f8db2" args="(sBufferMedia *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_NextForeach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continue la boucle foreach like sur le buffer média. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un paquet) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="ca27f598c501dc91f1b4556bedb6c1e0"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_Print" ref="ca27f598c501dc91f1b4556bedb6c1e0" args="(const sBufferMedia *pBuffer, bool pBuffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferMedia_Print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche le contenu d'un buffer média. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à afficher</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffers</em>&nbsp;</td><td>Faut-il afficher le contenu des buffers ?</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b71a2b21e86d18a53722a9070c69e48"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_ReadMedia" ref="2b71a2b21e86d18a53722a9070c69e48" args="(sBufferMedia *pBuffer, FILE *pDestFile, sMediaNo *pReadedNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_ReadMedia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>pDestFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> *&nbsp;</td>
          <td class="paramname"> <em>pReadedNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simule la " lecture " d'un paquet du buffer (enregistre son payload dans un fichier, si pDestFile!=0, et supprime le paquet pointé par lectureNx). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à vider</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestFile</em>&nbsp;</td><td>Pour enregistrer le payload média (0= pas enreg)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pReadedNo</em>&nbsp;</td><td>MédiaNo du média lu (supprimé)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / y a-t-il eu un "déplacement" dans le buffer ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="37d79a8fb4cb51476a3580c8580b546a"></a><!-- doxytag: member="sBufferMedia.c::sBufferMedia_Release" ref="37d79a8fb4cb51476a3580c8580b546a" args="(sBufferMedia *pBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferMedia_Release           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Libère la mémoire allouée par un buffer média. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à vider</td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 7 18:21:25 2009 for VLC-SMPTE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
