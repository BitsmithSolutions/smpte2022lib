<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VLC-SMPTE:  VLC-SMPTE/DoxyCode/Code/sBufferMedia.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1> VLC-SMPTE/DoxyCode/Code/sBufferMedia.h File Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsBufferMedia.html">sBufferMedia</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure stockant les paquets média dans un arbre rouge-noire. Le buffer média de VLC est une liste chaînée, ce qui n'est pas optimal lors de nombreuses manipulations du buffer. Une ancienne version avec liste doublement chaînée est disponible au cas où (version précédente).  <a href="structsBufferMedia.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsBufferMedia.html">sBufferMedia</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#6fb6d04f09d456526ff473d3fd145d61">sBufferMedia_New</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Créé un buffer média Remarque : ne pas oublier de faire le ménage avec sBufferMedia_Release !  <a href="#6fb6d04f09d456526ff473d3fd145d61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#7581d642e923f64dd930dc1367bdcbed">sBufferMedia_Release</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Libère la mémoire allouée par un buffer média.  <a href="#7581d642e923f64dd930dc1367bdcbed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#b37d720dd39d208dc66d8de5c9fea33d">sBufferMedia_Print</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, bool pBuffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affiche le contenu d'un buffer média.  <a href="#b37d720dd39d208dc66d8de5c9fea33d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#1d8a8dab2e7d0e43e2ca7af07d89bde1">sBufferMedia_AddByReference</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, <a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *, bool pOver)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Est "l'équivalent" de media_receive de VLC : ajoute le paquet média au buffer, celui-ci étant trié par ordre de médiaNo. Remarque: Le buffer s'approprie le paquet média, cela veut dire que c'est le buffer média qui s'occupera de libérer la mémoire prise par le paquet!  <a href="#1d8a8dab2e7d0e43e2ca7af07d89bde1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#af5fc47d22e2b428a4451b46d88e8c32">sBufferMedia_Find</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne un pointeur vers le paquet média portant un certain médiaNo.  <a href="#af5fc47d22e2b428a4451b46d88e8c32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#3ed65386e2b2c35b8057c565d8c9bb41">sBufferMedia_InitForeach</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, bool pReverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initalise la boucle foreach like sur le buffer média.  <a href="#3ed65386e2b2c35b8057c565d8c9bb41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#0f6a07698568b2f6333ebb60eeaa700f">sBufferMedia_NextForeach</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Continue la boucle foreach like sur le buffer média.  <a href="#0f6a07698568b2f6333ebb60eeaa700f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#0e2b54f6fa77b781904bc74b2ad20aa4">sBufferMedia_ForeachKey</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne le médiaNo du paquet média (pointé) par la boucle foreach.  <a href="#0e2b54f6fa77b781904bc74b2ad20aa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#b060e6159823ccf029cd4c5cd5fee6e3">sBufferMedia_ForeachValue</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retourne un pointeur sur le paquet média (pointé) par la boucle foreach.  <a href="#b060e6159823ccf029cd4c5cd5fee6e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#334b75b1965130331aa820e948f98431">sBufferMedia_IsMediaNoInBuffer</a> (const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calcule si un médiaNo se situe entre les limites d'arrivalNx &amp; readingNx La valeur de médiaNo est modulaire donc 2 cas de figures se présentent : cas [1] 0 false [readingNo] true [arrivalNo] false MAX cas [2] 0 true [arrivalNo] false [readingNo] true MAX.  <a href="#334b75b1965130331aa820e948f98431"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sBufferMedia_8h.html#cf98c253a9e68ed8da5378a7838ea0f8">sBufferMedia_ReadMedia</a> (<a class="el" href="structsBufferMedia.html">sBufferMedia</a> *, FILE *, <a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> *pReadedNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simule la " lecture " d'un paquet du buffer (enregistre son payload dans un fichier, si pDestFile!=0, et supprime le paquet pointé par lectureNx).  <a href="#cf98c253a9e68ed8da5378a7838ea0f8"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1d8a8dab2e7d0e43e2ca7af07d89bde1"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_AddByReference" ref="1d8a8dab2e7d0e43e2ca7af07d89bde1" args="(sBufferMedia *, sPaquetMedia *, bool pOver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_AddByReference           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pMedia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pOver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Est "l'équivalent" de media_receive de VLC : ajoute le paquet média au buffer, celui-ci étant trié par ordre de médiaNo. Remarque: Le buffer s'approprie le paquet média, cela veut dire que c'est le buffer média qui s'occupera de libérer la mémoire prise par le paquet! 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à modifier</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMedia</em>&nbsp;</td><td>Paquet à ajouter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pOver</em>&nbsp;</td><td>Faut-il écraser un noeud qui porterait déjà key=médiaNo ?</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / ajout réussi ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="af5fc47d22e2b428a4451b46d88e8c32"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_Find" ref="af5fc47d22e2b428a4451b46d88e8c32" args="(const sBufferMedia *, sMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a>* sBufferMedia_Find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne un pointeur vers le paquet média portant un certain médiaNo. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à traiter</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pMediaNo</em>&nbsp;</td><td>Paramètre de recherche</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur le paquet média lié à key=pMediaNo ou 0 si aucun de trouvé</dd></dl>

</div>
</div><p>
<a class="anchor" name="0e2b54f6fa77b781904bc74b2ad20aa4"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_ForeachKey" ref="0e2b54f6fa77b781904bc74b2ad20aa4" args="(const sBufferMedia *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> sBufferMedia_ForeachKey           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne le médiaNo du paquet média (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>médiaNo du paquet média (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="b060e6159823ccf029cd4c5cd5fee6e3"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_ForeachValue" ref="b060e6159823ccf029cd4c5cd5fee6e3" args="(const sBufferMedia *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsPaquetMedia.html">sPaquetMedia</a>* sBufferMedia_ForeachValue           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retourne un pointeur sur le paquet média (pointé) par la boucle foreach. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointeur sur la paquet média (pointé) par la boucle foreach ou 0 si inactif</dd></dl>

</div>
</div><p>
<a class="anchor" name="3ed65386e2b2c35b8057c565d8c9bb41"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_InitForeach" ref="3ed65386e2b2c35b8057c565d8c9bb41" args="(sBufferMedia *, bool pReverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_InitForeach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pReverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initalise la boucle foreach like sur le buffer média. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un paquet) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="334b75b1965130331aa820e948f98431"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_IsMediaNoInBuffer" ref="334b75b1965130331aa820e948f98431" args="(const sBufferMedia *, sMediaNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_IsMediaNoInBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a>&nbsp;</td>
          <td class="paramname"> <em>pMediaNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calcule si un médiaNo se situe entre les limites d'arrivalNx &amp; readingNx La valeur de médiaNo est modulaire donc 2 cas de figures se présentent : cas [1] 0 false [readingNo] true [arrivalNo] false MAX cas [2] 0 true [arrivalNo] false [readingNo] true MAX. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Est-ce que médiaNo se situe dans la zone entre lecture et arrivée (buffer) ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="6fb6d04f09d456526ff473d3fd145d61"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_New" ref="6fb6d04f09d456526ff473d3fd145d61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> sBufferMedia_New           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Créé un buffer média Remarque : ne pas oublier de faire le ménage avec sBufferMedia_Release ! 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Nouveau buffer média</dd></dl>

</div>
</div><p>
<a class="anchor" name="0f6a07698568b2f6333ebb60eeaa700f"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_NextForeach" ref="0f6a07698568b2f6333ebb60eeaa700f" args="(sBufferMedia *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_NextForeach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Continue la boucle foreach like sur le buffer média. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / Est-ce que ForeachData est (un paquet) valide ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="b37d720dd39d208dc66d8de5c9fea33d"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_Print" ref="b37d720dd39d208dc66d8de5c9fea33d" args="(const sBufferMedia *, bool pBuffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferMedia_Print           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Affiche le contenu d'un buffer média. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à afficher</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBuffers</em>&nbsp;</td><td>Faut-il afficher le contenu des buffers ?</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf98c253a9e68ed8da5378a7838ea0f8"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_ReadMedia" ref="cf98c253a9e68ed8da5378a7838ea0f8" args="(sBufferMedia *, FILE *, sMediaNo *pReadedNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sBufferMedia_ReadMedia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>pDestFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sSeqNx_8h.html#3cb19b0cda591ec2bc8d6d32befb7079">sMediaNo</a> *&nbsp;</td>
          <td class="paramname"> <em>pReadedNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simule la " lecture " d'un paquet du buffer (enregistre son payload dans un fichier, si pDestFile!=0, et supprime le paquet pointé par lectureNx). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à vider</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestFile</em>&nbsp;</td><td>Pour enregistrer le payload média (0= pas enreg)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pReadedNo</em>&nbsp;</td><td>MédiaNo du média lu (supprimé)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status de l'opération / y a-t-il eu un "déplacement" dans le buffer ?</dd></dl>

</div>
</div><p>
<a class="anchor" name="7581d642e923f64dd930dc1367bdcbed"></a><!-- doxytag: member="sBufferMedia.h::sBufferMedia_Release" ref="7581d642e923f64dd930dc1367bdcbed" args="(sBufferMedia *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sBufferMedia_Release           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsBufferMedia.html">sBufferMedia</a> *&nbsp;</td>
          <td class="paramname"> <em>pBuffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Libère la mémoire allouée par un buffer média. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBuffer</em>&nbsp;</td><td>Buffer à vider</td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Sep 7 18:21:25 2009 for VLC-SMPTE by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
